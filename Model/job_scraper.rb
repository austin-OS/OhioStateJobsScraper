# frozen_string_literal: true

#
# Created by Thomas Li
# Written 23 September 2022
#

require 'mechanize'
require 'json'
require_relative 'facet'
require_relative 'job_listing'

##
# This class handles the process of retrieving job listings
# from the OSU Workday page, using user-set search text and
# filter options (referred to as "facets" in the site's
# API) to refine the query.
#
# Mathematical Model:
#   this = (
#     site_url : string of character,
#     request_base : string of character,
#     request_path : string of character,
#     min_query_size : integer,
#     max_query_size : integer,
#     facets : string of Facet,
#     applied_facets : map of string of character to
#     string of character,
#     search_text : string of character
#   )
#   [The state consists of the URL info for accessing the
#   website and making requests for JSON data, constraints
#   for the possible sizes of requests, a list of possible
#   filter settings, the lists of applied options for each
#   setting to use in requests, and the search text to use
#   in requests]
#
# The following methods are available:
#   initialize(
#     site_url,
#     request_base,
#     request_path,
#     min_query_size,
#     max_query_size
#   )
#   save_as_hash()
#   load_from_hash!(data_hash)
#   retrieve_facets!()
#   facet_names()
#   facet_info(facet_name)
#   applied_facet_options(facet_name)
#   select_facet_option!(facet_name, facet_option_id)
#   deselect_facet_option!(facet_name, facet_option_id)
#   facet_option_selected?(facet_name, facet_option_id)
#   set_search_text(text)
#   search_text()
#   num_matching_jobs()
#   query(num_jobs: nil, start_index: 0)
#
class JobScraper
  ##
  # The constructor.
  #
  # @param site_url : string of character
  #   The URL of the actual website, from which the pages
  #   for the individual job listings can be access by
  #   attaching their respective external paths
  # @param request_base : string of character
  #   The base URL from which the path for retrieving the
  #   list of job postings, as well as the paths for
  #   retrieving information about the individual postings
  #   on their respective external pages, are attached to
  # @param request_path : string of character
  #   The path to attach to the request base URL in order
  #   to make requests
  # @param min_query_size : integer
  #   The lowest number of listings that can be retrieved
  #   in a request without the site returning an error,
  #   used for "dry run" requests that serve only to
  #   retrieve facet options or the count or matching jobs
  # @param max_query_size : integer
  #   The highest number of listings that can be retrieved
  #   in a request without the site returning an error,
  #   with the object making multiple requests of this
  #   size to simulate larger queries
  #
  # @requires
  #   min_query_size <= max_query_size
  # @ensures
  #
  def initialize(site_url, request_base, request_path, min_query_size, max_query_size)
    # record URL info
    @site_url = site_url
    @request_base = request_base
    @request_path = request_path

    # record request constraints
    @min_query_size = min_query_size
    @max_query_size = max_query_size

    # create user agent for making requests
    @agent = Mechanize.new

    # prepare set of parameters to send in requests
    @request_params = {
      appliedFacets: {},
      limit: @min_query_size,
      offset: 0,
      searchText: ''
    }
    @request_headers = {
      'Content-Type' => 'application/json'
    }

    # retrieve facet list
    @facets = nil
    retrieve_facets!
  end

  ##
  # Return a hash containing the object's stored data,
  # other than the constructor parameters, that allows
  # the state to be restored by passing the return value
  # to be passed into the load_from_hash method into
  # any initialized object
  def save_as_hash
    # put request params (including applied facets) and
    # facet list in return value
    {
      'request_params': @request_params,
      'facets': save_facets
    }
  end

  ##
  # Load the state of the object using a hash in the
  # same format as generated by the save_as_hash method
  def load_from_hash!(data_hash)
    # handle possibility that keys were converted from
    # symbols to strings if hash was translated to and
    # from JSON string
    data_hash['request_params'].each do |param_name, param_val|
      data_hash['request_params'][param_name.to_sym] = param_val if param_name.is_a?(String)
    end
    # store request params and facet list
    @request_params.each_key do |param_name|
      @request_params[param_name] = data_hash['reqeust_params'][param_name]
    end

    load_facets!(result['facets'])
  end

  ##
  # Helper function to perform HTTP POST request with
  # stored URL and params and return response object, with
  # no additional config or processing.
  def http_post
    @agent.post("#{@request_base}#{@request_path}", JSON.generate(@request_params), @request_headers)
  end

  ##
  # Refresh the list of facets and facet options, including
  # information on the number of matching jobs for each
  # option given the currently-selected options
  def retrieve_facets!
    # perform "dry run" query that retrieves the minimum
    # possible number of actual listings
    @request_params[:limit] = @min_query_size
    query = http_post

    # look through data field containing facets
    # and store each entry
    retrieved_facets = JSON.parse(query.content)['facets']
    load_facets!(retrieved_facets)

    # update applied facets in accordance with changes
    @request_params[:appliedFacets].each do |facet_name, applied_options|
      if @facets.key?(facet_name)
        applied_options.each do |facet_option_id|
          applied_options.delete(facet_option_id) if @facets[facet_name].find_option_by_id(facet_option_id).nil?
        end
      else
        @request_params[:appliedFacets].delete(facet_name)
      end
    end
  end

  ##
  # Helper function to store information about facets,
  # given as a hash, inside the object
  def load_facets!(facet_list)
    @facets = {}
    facet_list.each do |facet_data|
      # the location facet is nested inside another facet
      # for some reason - we need to account for this
      facet_data = facet_data['values'][0] until facet_data.key?('descriptor')

      # create Facet and FacetObject objects to record
      # data in
      facet_object = Facet.new(
        facet_data['facetParameter'],
        facet_data['descriptor']
      )
      facet_data['values'].each do |facet_option_data|
        facet_object.add_option!(
          facet_option_data['id'],
          facet_option_data['descriptor'],
          facet_option_data['count']
        )
      end

      @facets[facet_object.name] = facet_object
    end
  end

  ##
  # Helper function that reverses process of load_facets!
  # to return hash containing facet info that can be
  # passed back into a JobListing object
  def save_facets
    result = []
    @facets.each_value do |facet_object|
      facet_data = {
        'facetParameter': facet_object.name,
        'descriptor': facet_object.descriptor,
        'values': []
      }
      facet_object.options.each do |facet_option|
        facet_option_data = {
          'id': facet_option.id,
          'descriptor': facet_option.descriptor,
          'count': facet_option.count
        }
        facet_data['values'].push(facet_option_data)
      end
      result.push(facet_data)
    end
    result
  end

  ##
  # Return the list of internal names of the facets that
  # can be applied
  def facet_names
    @facets.keys
  end

  ##
  # Returns the information associated with a facet, as
  # a Facet object
  def facet_info(facet_name)
    @facets[facet_name]
  end

  ##
  # Returns a list of selected option values for the
  # given facet, as an array of the IDs
  #
  # @param facet_name
  #   The internal name of the facet
  def applied_facet_options(facet_name)
    (@request_params[:appliedFacets].key?(facet_name) ? @request_params[:appliedFacets][facet_name] : nil)
  end

  ##
  # Add the given option for the given facet to the
  # request params by ID, unless it's already there.
  #
  # @param facet_name
  #   The internal name of the facet to add the option for
  # @param facet_option
  #   A reference to the FacetOption object containing the
  #   option value to add
  def select_facet_option!(facet_name, facet_option_id)
    # create array in params object to store option values
    # if not already present
    @request_params[:appliedFacets][facet_name] = [] unless @request_params[:appliedFacets].key?(facet_name)

    # the site applies options based on IDs
    # add the ID to select the option
    unless @request_params[:appliedFacets][facet_name].include?(facet_option_id)
      @request_params[:appliedFacets][facet_name].push(facet_option_id)
    end
  end

  ##
  # Remove the given option from the request params by ID,
  # and return a reference to the corresponding object,
  # returning nil if none is found
  #
  # @param facet_name
  #   The internal name of the facet to remove the option
  #   for
  # @param facet_option_id
  #   The ID of the FacetOption object containing the
  #   option value to remove
  def deselect_facet_option!(facet_name, facet_option_id)
    removed_option = nil
    if @request_params[:appliedFacets].key?(facet_name)
      removed_option = facet_name.find_option_by_id(facet_option_id)
      @request_params[:appliedFacets][facet_name].delete(facet_option_id)
    end
    removed_option
  end

  ##
  # Check whether the option for a given facet
  # corresponding to a given ID is part of the request
  # params
  #
  # @param facet_name
  #   The internal name of the facet to check
  # @param facet_option_id
  #   The ID of the FacetOption object containing the
  #   option value to check
  def facet_option_selected?(facet_name, facet_option_id)
    @request_params[:appliedFacets].key?(facet_name) && @request_params[:appliedFacets][facet_name].include?(facet_option_id)
  end

  ##
  # Mutator for search text.
  def set_search_text(text)
    request_params[:searchText] = text
  end

  ##
  # Accessor for search text.
  def search_text
    request_params[:searchText]
  end

  def num_matching_jobs
    # perform "dry run" query that retrieves the minimum
    # possible number of actual listings
    @request_params[:limit] = @min_query_size
    query = http_post

    # return data field containing total count
    JSON.parse(query.content)['total']
  end

  ##
  # Perform a query given the stored parameters, return
  # the resulting list of jobs as a JSON object
  #
  # @param num_jobs : integer
  #   The number of listings to return, set to nil to
  #   retrieve all matching jobs after the start index
  # @param start_index : integer
  #   The index within the overall list of results to
  #   start retrieving from, set to 0 by default
  def query(num_jobs: nil, start_index: 0)
    # check bounds
    max_jobs = num_matching_jobs - start_index
    min_jobs = @min_query_size
    num_jobs = max_jobs if num_jobs.nil? || num_jobs > max_jobs
    num_jobs = min_jobs if num_jobs < min_jobs

    # prepare parameters for HTTP request
    @request_params[:limit] = @max_query_size
    @request_params[:offset] = start_index

    # perform requests
    # given limit on jobs per query, may need to split
    # query into multiple requests
    listings = []
    while num_jobs.positive?
      # set number of jobs to retrieve
      @request_params[:limit] = num_jobs if num_jobs < @request_params[:limit]
      num_jobs -= @request_params[:limit]

      # retrieve jobs, store listings in result array
      query = http_post
      JSON.parse(query.content)['jobPostings'].each do |job_data|
        listings.push(JobListing.new(
                        @site_url,
                        @request_base,
                        job_data
                      ))
      end
    end

    # return results
    listings
  end

  # set helper functions as private to streamline
  # visible interface
  private :http_post, :load_facets!, :save_facets
end
